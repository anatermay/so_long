# SO_LONG

## Planificación

El objetivo es completar la implementación y correcta funcionalidad de las características clave del videojuego básico 2D en C con los recursos de 42 para mejorar las habilidades en programación y aprender el manejo de gráficos.

Los principales desafíos del proyecto son:

* Cargar y mostrar el mapa correctamente.
* El jugador debe poder moverse en las cuatro direcciones empleando las teclas de flecha o las teclas WASD.
* Deben registrarse los progresos:
  * Objetos recolectados.
  * Enemigos esquivados.

_*TO DO LIST*_

1. Fase de Planificación y Diseño:
	* Definir la estructura general del proyecto.
	* Planificar el mapa y los objetos interactivos.
	* Especificar las teclas de control y las mecánicas básicas.
2. Fase de Desarrollo Inicial:
   * Implementar la carga y visualización del mapa.
   * Desarrollar las funciones básicas de control del jugador.
   * Crear las primeras versiones de los sprites y las interacciones básicas (como movimiento).
3. Fase de Integración de Funciones:
   * Integrar el sistema de colisiones y las interacciones con los objetos del mapa.
   * Implementar el registro de progresos y el manejo de enemigos.
4. Fase de Optimización y Pruebas:
	* Probar la funcionalidad general del juego.
	* Depurar cualquier error o fallo.
	* Optimizar la carga y gestión de recursos.
5. Fase de Documentación y Entrega:
	* Crear la documentación detallada del código y el proyecto.
	* Realizar pruebas finales y asegurarse de que todas las funcionalidades están completas y operativas.
	* Preparar el proyecto para su entrega final.

### PARA

PARA es un acrónimo que corresponde a cuatro categorías principales: Proyectos, Áreas de responsabilidad, Recursos y Archivo. Este sistema fue creado por Tiago Forte, el mismo creador del sistema CODE, y se basa en organizar toda tu información de manera clara y funcional.

Voy a explicarte cada uno de los cuatro componentes de PARA y cómo puede ayudarte a ser más productivo.

1. **Proyectos**
Este apartado está destinado a todas aquellas tareas o iniciativas que estás trabajando en un momento específico. Son actividades con un objetivo claro y un resultado tangible. Pueden ser cosas como “Escribir el siguiente capítulo de mi libro”, “Crear una campaña para Instagram” o “Lanzar un nuevo curso online”. Los proyectos son lo que te lleva a la acción y te mantiene enfocado en lo que quieres lograr. Lo importante aquí es que solo debes tener proyectos activos que realmente estén en progreso. Si hay algo que no has comenzado aún o que está esperando a ser revisado, no debería estar en esta categoría.

1. **Áreas de Responsabilidad**
Las áreas de responsabilidad son áreas continuas en tu vida o trabajo que requieren atención constante. Son cosas que no tienen una fecha de finalización, pero que son esenciales para tu vida o negocio. Ejemplos de áreas de responsabilidad pueden ser “Salud y bienestar”, “Gestión de redes sociales” o “Atención al cliente”. Estas áreas engloban todo lo que debes mantener en marcha a largo plazo, pero no necesariamente están asociadas a proyectos específicos. Si tienes responsabilidades que deben cumplirse de manera continua, deberían estar en esta categoría.

3. Recursos
Esta categoría incluye toda la información, herramientas o materiales que utilizas para realizar tus proyectos o gestionar tus áreas de responsabilidad. Aquí es donde se almacenan las fuentes de conocimiento, las plantillas, los libros, los artículos, las apps y cualquier otra cosa que te sirva como apoyo en tu trabajo o vida diaria. Es clave tener tus recursos bien organizados para que, cuando necesites algo, lo encuentres rápidamente. Si alguna vez has guardado una idea o enlace interesante para más tarde y luego no lo encuentras, sabrás lo frustrante que puede ser. Con PARA, toda esa información está organizada y lista para ser utilizada.

1. Archivo
Esta categoría es para todo lo que ya no está activo, pero que deseas guardar para referencia futura. Pueden ser proyectos que ya has completado, documentos antiguos o cualquier información que ya no necesitas, pero que puede ser útil más adelante. El archivo es tu espacio para todo lo que ya no es necesario en tu día a día pero que quieres conservar. Es como un cajón de recuerdos o un armario donde guardas lo que has hecho y que puede tener valor en el futuro.

El sistema PARA tiene muchas ventajas, pero lo más importante es que te ayuda a organizar tu vida y trabajo de manera clara y estructurada. Al dividir la información en estas cuatro categorías, se facilita mucho la toma de decisiones sobre qué hacer a continuación. En lugar de estar abrumado por una lista interminable de tareas y notas, sabes exactamente qué necesita tu atención inmediata (Proyectos) y qué puede esperar (Áreas de Responsabilidad).

Además, tener todo organizado de manera lógica y sencilla te permite encontrar la información rápidamente. Ya no perderás tiempo buscando archivos antiguos o ideas dispersas por diferentes plataformas, porque todo tiene su lugar.

Por último, el sistema PARA también ayuda a que no te sientas tan disperso. Muchas veces tenemos muchas ideas y proyectos a la vez, pero con PARA puedes ver claramente qué estás trabajando ahora, qué áreas requieren tu atención regular y qué materiales necesitas para avanzar. Esto te permite estar más enfocado y, en consecuencia, ser más productivo.

Mientras que CODE se centra en organizar ideas y el proceso creativo, PARA se enfoca más en organizar toda la información en tu vida, tanto a nivel personal como profesional. Para aquellos que buscan una manera simple y efectiva de gestionar proyectos y responsabilidades sin complicarse demasiado, PARA es una opción ideal. A diferencia de otros métodos que pueden volverse un poco más filosóficos o abstractos, el sistema PARA es directo y práctico, lo que lo convierte en una excelente opción para quienes buscan una organización más accesible y fácil de implementar.

El sistema PARA es una herramienta poderosa para organizar todos los aspectos de tu vida y tu trabajo. Si alguna vez te has sentido perdido entre tareas, proyectos e información dispersa, este método puede ser justo lo que necesitas para poner orden y claridad en tu día a día. Al dividir la información en cuatro categorías claras (Proyectos, Áreas de Responsabilidad, Recursos y Archivo), podrás ser más eficiente y mantenerte enfocado en lo que realmente importa.

### CODE

CODE, un sistema creado por Tiago Forte, simplifica la gestión de información y la transforma en algo útil y accionable. Es un acrónimo que representa cuatro pasos clave para procesar la información de manera eficiente:

* Capturar: Recoger información valiosa (ideas, citas, artículos, notas, reflexiones) que pueda ser útil en el futuro.
* Organizar: Clasificar y estructurar la información de forma accesible y fácil de encontrar.
* Destilar: Resumir, sintetizar y extraer lo más relevante para no ahogarnos en datos innecesarios.
* Expresar: Convertir esa información en algo tangible: un texto, una idea desarrollada, un proyecto.

Este proceso nos ayuda a visualizar cómo una simple idea puede evolucionar hasta convertirse en algo concreto y significativo.

Este sistema tiene tres grandes ventajas:

* Facilita la gestión de ideas: En lugar de dejar que se acumulen en una libreta o una carpeta digital sin orden, las organizamos para que sean fáciles de recuperar y usar.
* Funciona como un "segundo cerebro": Nos ayuda a liberar espacio mental y a estructurar el pensamiento de forma más clara.
* Prioriza la acción y la creatividad: No se trata solo de almacenar información, sino de hacer algo con ella.

Imagina que estás investigando para un proyecto o simplemente leyendo algo interesante. Con CODE, el proceso sería algo así:

1. Capturas una idea brillante que lees en un libro.
2. La organizas en una carpeta específica de tu ordenador o en una aplicación de notas con etiquetas útiles.
3. La destilas, resumiendo su esencia en una frase o anotando cómo se conecta con lo que ya sabes.
4. La expresas, integrándola en un artículo, una presentación o un plan de acción.

Este método es flexible y se adapta a cualquier tipo de proyecto, desde escribir una novela hasta planificar una estrategia de marketing.

No necesitas herramientas complicadas. Lo importante es crear un sistema que funcione para ti y que te ayude a dar vida a tus ideas en lugar de dejarlas olvidadas.

### PARA-CODE

Al integrar estos dos sistemas, puedes crear un flujo de trabajo estructurado que te ayudará a ser más productivo y creativo.

* Proyectos
  1. Almacenar todo lo que se te ocurra relacionado con tus proyectos activos, sin preocuparte por el orden o la calidad. Si estás trabajando en un libro, captura cualquier idea que venga a tu mente: fragmentos de diálogos, conceptos de personajes, eventos de la trama, etc. Simplemente anota todo lo que se te ocurra, ya sea en un cuaderno o en una aplicación como Notion o Evernote. Luego, tendrás toda esa información lista para ser organizada y desarrollada.
  2. Una vez que has capturado tus ideas y materiales, el siguiente paso es agrupar, clasificar y estructurar toda la información que has capturado en torno a un proyecto específico. Tienes tu libro a medio escribir, y has capturado varias ideas. Ahora, en la fase de organización, clasificas esas ideas: creas una estructura del libro, asignas cada idea a un capítulo o escena en particular. Organizar también podría implicar priorizar las tareas dentro del proyecto para saber por dónde empezar.
  3. La destilación implica reducir el volumen de ideas y hacer que las más relevantes se destaquen. Tienes varias ideas para el capítulo 3 de tu libro, pero no todas son necesarias. La destilación te ayuda a reducir esas ideas a las más potentes, las que realmente avanzan la trama. Tal vez deshagas algunas ideas o las combines para hacer algo más sólido.
  4. La fase de expresión es es el momento de poner en práctica lo que has planificado. Después de organizar tus ideas y destilar las más importantes, empieza a escribir ese capítulo de tu libro. En lugar de tener ideas dispersas, ahora las has transformado en contenido concreto.

* Área de Responsabilidad
  1. En este caso, capturas todo lo relacionado con tareas continuas que requieren tu atención regular. Si gestionas tus redes sociales, captura ideas para nuevas publicaciones, artículos de interés o recursos útiles sobre el tema. Es posible que un día notes un artículo sobre marketing digital que puede ser útil para tus proyectos, o tal vez tienes una idea de cómo mejorar tu estrategia de contenido. Todo esto se captura aquí, sin importar si es urgente o no.
  2. La organización es crucial para mantener las cosas bajo control. Organizar puede implicar dividir esta tarea en subcategorías, como “Redactar posts”, “Investigar tendencias”, “Responder comentarios”, etc. De este modo, sabrás exactamente qué acciones tomar en cada momento.
  3. La destilación aplicada a tus Áreas de Responsabilidad te ayudará a eliminar tareas innecesarias o a concentrarte en lo que realmente importa: _REGLA 80/20 DE PARETO_. Si tu área de responsabilidad es la gestión de tus redes sociales, tal vez te des cuenta de que algunas tareas no son tan relevantes como pensabas. Puedes destilar esas tareas para concentrarte solo en las que realmente impactan tu audiencia.
  4. La expresión implica la implementación de acciones. Si tu área de responsabilidad es responder mensajes en redes sociales, la expresión sería actuar. Responde a los comentarios y mensajes de tus seguidores, interactúa de forma auténtica.

* Recursos
  1. Almacenar materiales útiles, pero no necesariamente urgentes. Si estás investigando sobre algún tema para un futuro libro o proyecto, puedes capturar links, libros, artículos o videos que consideres útiles. También puedes guardar notas de cualquier seminario, curso o charla que hayas visto. La clave es capturar todo lo que pueda ser útil más adelante.
  2. Organizar esos recursos de manera que te sea fácil acceder a ellos cuando los necesites. Si has guardado muchos artículos sobre marketing digital, puedes organizarlos en categorías como “Estrategias de contenido”, “SEO”, “Publicidad pagada” y “Email marketing”. Esto te permitirá acceder rápidamente a la información que necesites.
  3. El objetivo es quedarte solo con lo más importante. Si tienes una gran cantidad de artículos guardados sobre desarrollo personal, destílalos. Elimina los que no aportan mucho y quédate con los que realmente te ayudan a crecer o que puedes utilizar directamente en tus proyectos.
  4. Se trata de poner esos materiales a trabajar. Tienes un recurso valioso, como un artículo sobre productividad. En la fase de expresión, lo compartes con tu audiencia en un post o lo usas como base para un contenido de video. Estás transformando ese recurso en algo útil para tu comunidad.

* Archivo
  1. Guardar información que ya no es activa, pero que podrías necesitar en el futuro. Si has completado un proyecto y ya no está en curso, puedes guardar todos los documentos, investigaciones, materiales o recursos que usaste en el proceso. Todo esto se guarda en un archivo para referencia futura.
  2. El archivo puede acumularse rápidamente, por lo que es importante organizar los archivos antiguos y decidir qué hacer con ellos. Si tienes una carpeta llena de documentos antiguos, organiza por categorías o fechas. Puedes archivarlo en carpetas físicas o digitales con un sistema claro, como "Proyectos Completados" o "Referencias antiguas". Así podrás encontrar lo que necesitas en el futuro sin perder tiempo.
  3. El proceso te ayuda a decidir qué documentos y materiales realmente valen la pena guardar y cuáles puedes descartar. Revisa tus archivos antiguos y elimina los documentos que ya no tienen valor. Tal vez un proyecto que ya está terminado no necesita tantos archivos guardados; simplifica y guarda solo lo que te será útil en el futuro.
  4. Usar algo antiguo para un nuevo proyecto. Tal vez guardaste una entrevista antigua o un artículo que escribiste en el pasado. Puedes reciclar o volver a utilizar ese contenido para algo nuevo, como un blog post o un artículo en redes sociales.

#### Regla 80/20 de Pareto

La **regla 80/20**, también conocida como el principio de Pareto, es un concepto simple pero poderoso que puede cambiar la manera en la que gestionas tu tiempo, proyectos y recursos. Fue propuesta por el economista italiano Vilfredo Pareto a principios del siglo XX, quien observó que aproximadamente el 80% de los resultados provienen del 20% de los esfuerzos. Este principio se aplica a una amplia variedad de campos, desde los negocios hasta la vida personal.

Imagina que tienes una lista de tareas o proyectos. Según la regla 80/20, es probable que el 20% de esas tareas sea responsable de el 80% del impacto o los resultados que logras. Este patrón se repite en muchos aspectos de la vida y los negocios.

* Priorización: Identifica el 20% de tus tareas que tienen el mayor impacto. Dedica más tiempo y recursos a esas actividades clave y menos a las que no contribuyen tanto a tus objetivos. Esto puede ayudarte a ser más productivo y a tomar decisiones más efectivas.
* Optimización de Recursos: En lugar de dispersarte en múltiples esfuerzos que no generan grandes resultados, concentra tus recursos en lo que realmente importa. Por ejemplo, si estás trabajando en un proyecto como un libro, identifica qué aspectos del proceso (escritura, investigación, marketing) realmente marcan la diferencia en la calidad final.
* Mejora continua: La regla 80/20 también puede ayudarte a identificar áreas de mejora. Si sabes que el 20% de tus clientes está generando la mayoría de tus ingresos, puedes optimizar la atención y fidelización de esos clientes clave para mejorar aún más los resultados.

La regla 80/20 de Pareto nos enseña a ser más inteligentes con el uso de nuestros recursos y tiempo. Nos invita a reflexionar sobre cómo podemos enfocar nuestros esfuerzos en lo que realmente produce resultados significativos y minimizar el desperdicio de energía en tareas que no aportan tanto. Si aplicamos este principio de manera consciente, podemos maximizar nuestros resultados y ser más eficientes en todo lo que hacemos.

#### Tabla de Prioridad

La tabla de prioridad importante-urgente, también conocida como la **matriz de Eisenhower**, es una herramienta de gestión del tiempo creada por el presidente de EE.UU. Dwight D. Eisenhower. Este método nos ayuda a clasificar nuestras tareas según dos criterios clave: importancia y urgencia, de manera que podamos tomar decisiones más claras sobre qué hacer primero.

La matriz se divide en cuatro cuadrantes:
* Cuadrante 1: Importante y Urgente - Son tareas que requieren atención inmediata y son clave para alcanzar tus objetivos. Estas tareas deben hacerse de inmediato, como responder una crisis o una emergencia laboral.
* Cuadrante 2: Importante, pero No Urgente - Estas tareas son fundamentales para tu éxito a largo plazo, pero no requieren acción inmediata. Aquí se encuentran actividades como la planificación, el desarrollo personal, la creación de proyectos a largo plazo o la mejora continua. Deberías hacerlas pronto, antes de que se conviertan en urgentes.
* Cuadrante 3: No Importante, pero Urgente - Son tareas que requieren atención rápida, pero que no tienen un impacto significativo en tus objetivos a largo plazo. Muchas veces, estas tareas son interrupciones o solicitudes de otras personas. Debes delegarlas si es posible.
* Cuadrante 4: No Importante y No Urgente - Son actividades que no contribuyen significativamente a tus metas y que no tienen urgencia. Esto incluye distracciones como navegar en redes sociales o actividades que no agregan valor. Estas tareas deben eliminarse o minimizarse.

**¿Cómo Aplicarla a Tu Vida Diaria?**
1. Clasifica tus tareas: Todos los días, revisa tu lista de tareas y clasifícalas en los cuatro cuadrantes. Esto te ayudará a identificar qué acciones tomar primero.
2. Enfócate en lo importante: Da prioridad a las tareas del Cuadrante 2. Si constantemente te enfocas en lo importante y no urgente, puedes evitar que las tareas se conviertan en urgentes y reducir el estrés asociado con la procrastinación.
3. Delega lo que puedas: Si te enfrentas a tareas del Cuadrante 3, intenta delegarlas para concentrarte en lo que realmente importa.
4. Elimina lo innecesario: Evita caer en la trampa del Cuadrante 4. Si una tarea no contribuye a tus objetivos, probablemente sea una distracción que puedes eliminar.

La matriz de prioridad importante-urgente te permite tomar control de tu tiempo y reducir el estrés de la procrastinación. Al aprender a priorizar, puedes asegurarte de que tu energía y esfuerzo estén dirigidos a las actividades que realmente importan y te acercan a tus objetivos. Implementa esta herramienta en tu día a día y verás cómo mejoras tu productividad y bienestar.

### Sistema Aplicado al Proyecto So_Long

Antes de comenzar a trabajar en so_long, anota todas las ideas relacionadas con el proyecto: desde los requisitos del juego hasta posibles mejoras o características que podrías incluir. ¿Cómo quieres que sea la interfaz? ¿Qué tipo de interacción quieres entre el jugador y el mapa? Asegúrate de registrar todo lo que se te ocurra, incluso si no estás seguro de si lo usarás.

Registra cualquier tarea continua relacionada con el desarrollo del juego, como la investigación de nuevas funcionalidades, la actualización de tu entorno de desarrollo, o la solución de problemas recurrentes. Si se te ocurre una optimización o mejora, también debes capturarlo.

Después, organiza las tareas en fases del proyecto.

1. Desarrollo del código:
   1. Crear una ventana que muestre gráficos básicos usando la librería gráfica proporcionada para la funcionalidad básica del juego y la interacción del usuario.
   2. Implementar la funcionalidad del jugador para que se mueva en las cuatro direcciones respondiendo a las teclas de flecha y las teclas WASD empleando funciones de entrada de teclado y funciones de actualización de posición.
   3. Implementar la recolección de objetos y detección de enemigos utilizando la estructura del mapa y las funciones de detección de colisiones.
2. Documentación del proyecto.
3. Pruebas y depuración.

Comienza a trabajar en las tareas y funcionalidades de so_long de acuerdo con el plan. Escribe el código, crea el mapa, agrega los movimientos del jugador y las interacciones. Esto es donde transformas las ideas en algo concreto y funcional. Haz lo que se requiere para mantener el avance del proyecto.

No todas las ideas que tienes sobre cómo mejorar el juego son imprescindibles, así que elimina las que no van a agregar un valor directo. Prioriza tareas clave, como mejorar la jugabilidad o arreglar bugs que impactan la experiencia del jugador.

**¿Has encontrado un recurso?**
Guarda cualquier artículo, video, o material relacionado con el desarrollo de juegos que te pueda ser útil. Tal vez encuentres recursos sobre técnicas de animación, tutoriales sobre mlx, o documentación sobre las mejores prácticas de programación en C que puedas usar. Organiza estos recursos en carpetas o herramientas de gestión (como Notion, Evernote o Google Drive), de modo que sea fácil acceder a ellos cuando los necesites. Podrías categorizar por tipo de recurso: "tutoriales de programación", "ejemplos de gráficos 2D", "ideas de jugabilidad", etc. De los muchos recursos que puedas guardar, selecciona solo los que realmente necesitas o los que te ayudaron a resolver problemas concretos durante el desarrollo del juego. Elimina o archiva los que no sean relevantes a corto o medio plazo. Si encontraste un tutorial útil sobre cómo usar una biblioteca en mlx, ponlo en práctica en tu proyecto para mejorar la calidad gráfica del juego. Puedes incluso compartir lo aprendido en tu cuenta de Instagram si quieres inspirar a otros desarrolladores.

**Y ¿después?**
Guarda todo lo que hayas completado o que ya no esté en uso activo, pero que podría ser útil más tarde. Esto incluye versiones anteriores del código, recursos gráficos que no hayas usado o incluso una lista de ideas descartadas. Archiva esos elementos en carpetas estructuradas por fechas o fases del proyecto. Asegúrate de que cualquier cosa que ya no necesites sea fácil de localizar en el futuro si decides volver a ella. Aunque no todos los archivos necesitan ser conservados. Puedes revisar los archivos viejos y eliminar aquellos que ya no sean útiles, como versiones antiguas de código que han sido reemplazadas por una versión mejorada. Si decides que alguna idea del archivo es interesante para un futuro proyecto, no dudes en reutilizarla o reciclarla. Tal vez un recurso visual de un proyecto anterior se pueda aplicar en otro juego o incluso inspirar un nuevo elemento en so_long.

Aplicar estos sistemas de organización y flujo de trabajo a tu proyecto so_long te ayudará a mantenerte enfocado y productivo, gestionando no solo el desarrollo del código, sino también los recursos y tareas relacionadas con el proyecto de manera más eficiente. Esto te permitirá ser más creativo mientras mantienes la organización y reduces el estrés durante todo el proceso de creación.

## Estructura del Programa So_Long

La estructura de tu programa se organiza en diferentes carpetas y archivos para mantener el código limpio, modular y fácil de mantener. A continuación, se detalla la estructura propuesta, con una descripción de cada carpeta y archivo para clarificar su propósito dentro del proyecto:

1. graphics
   1. ILLUSTRATIONS.C
   2. PERSPECTIVE.C
2. header_file
   1. SO_LONG.H
3. mechanics
   1. CHARACTER_ARC.C
   2. NARRATIVE.C
   3. TURNING_PAGES.C
4. resources
   1. EDITORIAL.C
   2. EPILOGUE.C
   3. FOOT_NOTES.C
   4. gnl
   5. libft
   6. PLOT_TWIST.C
5. settings
   1. PROLOGUE.C
   2. WORLDBUILDING.C
6. MAKEFILE
7. README.MD
8. DOCUMENTATION.MD
9. SO_LONG.C

Con esta estructura de archivos, puedes organizar el desarrollo de manera que cada parte del código se enfoque en una tarea específica del juego:

1. Inicio y Preparación: Comienza con la configuración inicial del juego en so_long.c, prologue.c y la carga del mapa en worldbuilding.c.
2. Gráficos: Luego, pasa a implementar el manejo de las ilustraciones en illustrations.c y la perspectiva de los objetos en perspective.c.
3. Lógica del Juego: Trabaja en la mecánica del personaje y la narración del juego en character_arc.c y narrative.c.
4. Interacción: Desarrolla la lógica de eventos en turning_pages.c para que el jugador pueda interactuar con el juego.
5. Validación y Errores: Usa editorial.c para manejar errores y plot_twist.c para implementar la lógica de los caminos válidos en el mapa.

_**Beneficios de Esta Estructura**_

* Modularidad: Cada módulo se encarga de una parte específica del juego, lo que facilita el mantenimiento y la escalabilidad.
* Reutilización: Puedes reutilizar funciones de la libft y get_next_line sin duplicar código.
* Legibilidad: La división clara de responsabilidades mejora la comprensión del código y facilita la colaboración.
* Facilidad de depuración: Los errores pueden localizarse más fácilmente en el módulo correspondiente, lo que reduce el tiempo de depuración.

---

<img src="https://files.oaiusercontent.com/file-CJyqoR6gqnr7s1tkgZCCTn?se=2025-02-19T19%3A43%3A20Z&sp=r&sv=2024-08-04&sr=b&rscc=max-age%3D604800%2C%20immutable%2C%20private&rscd=attachment%3B%20filename%3D9a55fa33-da5c-46cf-aa81-b60b28b48d93.webp&sig=NFJkDwHekTAFrSz1g9LdbOP5yeRpRD11sssfNiQeDKg%3D" style="width: 254px; height: 254px">

1. **so_long**
   - **graphics**
     1. **illustrations.c**
        - load_sprites() - Carga las texturas y sprites.
        - render_sprites() - Dibuja los sprites en la pantalla.
        - draw_player() - Dibuja al jugador en su posición.
        - draw_enemy() - Dibuja los enemigos en el mapa.
        - unload_graphics() - Libera recursos gráficos al final.
     2. **perspective.c**
        - update_position() - Calcula nuevas posiciones de los objetos.
        - adjust_perspective() - Ajusta la perspectiva de la cámara.
        - move_object() - Mueve un objeto en la pantalla.
        - set_viewport() - Establece el área visible de la pantalla.
        - reset_perspective() - Restaura la perspectiva inicial.

   - **header_file**
     1. **so_long.h**
        - define_player() - Define las propiedades del jugador.
        - declare_sprites() - Declara los sprites y texturas.
        - create_map() - Crea el mapa del juego.
        - define_collision() - Define las colisiones del jugador.
        - declare_game_variables() - Declara las variables del juego.

   - **mechanics**
     1. **character_arc.c**
        - move_player() - Mueve al jugador según entradas de teclado.
        - check_collision() - Verifica si el jugador colisiona con objetos.
        - handle_death() - Maneja la lógica de muerte del jugador.
        - pick_up_item() - Lógica para recoger objetos.
        - animate_player() - Controla las animaciones del jugador.
     2. **narrative.c**
        - check_victory() - Verifica si el jugador ha ganado.
        - trigger_event() - Activa eventos de la narrativa.
        - update_score() - Actualiza la puntuación del jugador.
        - display_message() - Muestra mensajes narrativos al jugador.
        - reset_game() - Reinicia el juego después de una victoria o derrota.
     3. **turning_pages.c**
        - handle_key_input() - Maneja las teclas presionadas.
        - pause_game() - Pausa el juego.
        - close_game() - Cierra la ventana del juego.
        - resume_game() - Reanuda el juego después de pausar.
        - update_game_state() - Actualiza el estado del juego.

   - **resources**
     1. **editorial.c**
        - print_error() - Imprime mensajes de error.
        - show_warning() - Muestra advertencias en consola.
        - print_debug() - Imprime mensajes de depuración.
        - display_message() - Muestra mensajes generales.
        - log_to_file() - Registra mensajes en un archivo de log.
     2. **epilogue.c**
        - free_resources() - Libera recursos al final del juego.
        - close_window() - Cierra la ventana del juego correctamente.
        - save_game_state() - Guarda el estado del juego.
        - display_end_screen() - Muestra la pantalla de fin de juego.
        - reset_game_variables() - Reinicia las variables del juego.
     3. **foot_notes.c**
        - log_info() - Registra información útil durante la ejecución.
        - handle_warnings() - Maneja y muestra advertencias.
        - process_input() - Procesa la entrada del jugador.
        - cleanup_memory() - Limpia la memoria utilizada.
        - print_summary() - Imprime un resumen del juego.

   - **gnl**
     1. **get_next_line.c**
        - read_line() - Lee una línea del archivo.
        - handle_buffer() - Maneja el búfer para la lectura de archivos.
        - return_line() - Devuelve la línea leída.
        - clean_buffer() - Limpia el búfer tras leer una línea.
        - close_file() - Cierra el archivo después de leer.

   - **libft**
     1. **libft.c**
        - ft_strlen() - Calcula la longitud de una cadena.
        - ft_strcpy() - Copia una cadena de caracteres.
        - ft_memalloc() - Asigna memoria dinámica.
        - ft_strcmp() - Compara dos cadenas.
        - ft_itoa() - Convierte un número entero en una cadena.

   - **settings**
     1. **prologue.c**
        - initialize_game() - Inicializa las variables y parámetros del juego.
        - setup_window() - Configura la ventana del juego.
        - set_background() - Establece el fondo de la ventana.
        - set_colors() - Define los colores de la interfaz.
        - configure_game() - Configura la lógica general del juego.
     2. **worldbuilding.c**
        - load_map() - Carga el mapa desde un archivo.
        - validate_map() - Valida la estructura del mapa.
        - check_obstacles() - Verifica los obstáculos en el mapa.
        - render_map() - Dibuja el mapa en la pantalla.
        - unload_map() - Libera la memoria del mapa.

2. **Otros Archivos**
   - Makefile
   - README.md
   - SoftwareDevelopmentDocumentation.md
   - so_long.c
      1. main() - Función principal que inicializa y ejecuta el juego.
      2. initialize_game() - Inicializa las variables y configura el juego.
      3. game_loop() - El bucle principal del juego que maneja las entradas y actualizaciones.
      4. render_frame() - Dibuja la pantalla y actualiza la vista del juego.
      5. close_game() - Cierra el juego correctamente, liberando recursos.


---

## MANEJO DE ELEMENTOS GRÁFICOS Y VISUALES [GRAPHICS]

### illustrations.c

Este archivo se encarga de manejar las texturas, la carga de sprites y su renderizado en la pantalla. Incluye funciones que gestionan la visualización de los elementos gráficos como el jugador, los enemigos y los objetos del mapa.

### perspective.c

Se ocupa del cálculo de las posiciones de los elementos en la pantalla. Aquí se define cómo los elementos deben moverse en la interfaz gráfica, cómo se actualizan y cómo se dibujan en la ventana.

## ARCHIVOS DE CABECERA [HEADER_FILE]

### so_long.h

Contiene las definiciones de las estructuras de datos y las funciones clave que se usan en todo el proyecto. Este archivo es importante para que el código sea reutilizable en diferentes módulos.

## LÓGICA DEL JUEGO [MECHANICS]

### character_arc.c

Aquí se implementa la lógica del movimiento del jugador, incluyendo la detección de colisiones con los bordes del mapa, enemigos y objetos coleccionables. También incluye las animaciones si las hubiera.

### narrative.c

Controla el flujo del juego, incluyendo la detección de condiciones de victoria o derrota. Aquí se definen las reglas y eventos principales del juego.

### turning_pages.c

Este archivo maneja los eventos del juego, como la detección de teclas presionadas (para mover al jugador, pausar el juego, etc.), el cierre de la ventana, y otras interacciones con la interfaz de usuario.

## MANEJO DE RECURSOS Y FUNCIONES AUXILIARES [RESOURCES]

### editorial.c

Este archivo se encarga de la gestión de errores y la impresión de mensajes de consola durante la ejecución del juego. Ideal para mostrar mensajes de depuración, errores de carga o fallos en el sistema.

### epilogue.c

Se ocupa de liberar la memoria utilizada por el programa y cerrar correctamente el juego, asegurándose de que todos los recursos sean limpiados antes de que el programa termine.

### foot_notes.c

Contiene funciones auxiliares que no encajan en las categorías principales, como funciones de apoyo o tareas menores que son útiles en varias partes del código.

### get_next_line [gnl]

La implementación de la función get_next_line, que se reutiliza de tu proyecto anterior. Esta función será útil para leer datos de archivos, especialmente para cargar el mapa.

### LIBFT [libft]

Tu propia librería de funciones libft, reutilizada de proyectos anteriores. Contendrá funciones útiles como manejo de cadenas, memoria, y otras utilidades.

### plot_twist.c

Este archivo implementa el algoritmo para encontrar caminos válidos en el mapa, fundamental para la lógica de juego, ya que maneja la generación y validación de rutas a seguir por el jugador.

## CONFIGURACIÓN Y PREPARACIÓN DEL JUEGO [SETTINGS]

### prologue.c

Aquí se inicializan las variables y se configuran los parámetros iniciales del juego, como el tamaño de la ventana, los colores de fondo, y otras configuraciones generales.

### worldbuilding.c

Se encarga de la carga y validación del mapa desde un archivo .ber. Aquí se verifica la estructura y el contenido del mapa, asegurándose de que no haya errores antes de cargarlo en el juego.

## OTROS ARCHIVOS IMPORTANTES

### Makefile

Un archivo de configuración que define los comandos necesarios para compilar el proyecto. En él se incluyen las dependencias entre los archivos y las reglas para construir el proyecto.

### README.md

Este archivo proporciona una descripción general del proyecto, cómo compilarlo, ejecutarlo y detalles adicionales sobre la implementación y los objetivos.

### SoftwareDevelopmentDocumentation.md

Un archivo adicional donde se documentan detalles más profundos sobre el código, decisiones de diseño y otros aspectos técnicos relevantes para los desarrolladores o para una futura colaboración.

## RAÍZ DEL PROYECTO

### so_long.c

Este es el archivo principal del juego, responsable de la ejecución y control global del flujo del programa. Es el punto de entrada donde se inicia el juego.
